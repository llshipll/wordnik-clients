/**
* api.wordnik.com
* No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
*
* OpenAPI spec version: 4.0
* 
*
* NOTE: This class is auto generated by the swagger code generator program.
* https://github.com/swagger-api/swagger-codegen.git
* Do not edit the class manually.
*/
package io.swagger.client.apis

import io.swagger.client.models.AudioFile
import io.swagger.client.models.Bigram
import io.swagger.client.models.Definition
import io.swagger.client.models.Example
import io.swagger.client.models.ExampleSearchResults
import io.swagger.client.models.FrequencySummary
import io.swagger.client.models.Related
import io.swagger.client.models.Syllable
import io.swagger.client.models.TextPron
import io.swagger.client.models.WordObject

import io.swagger.client.infrastructure.*

class WordApi(basePath: kotlin.String = "https://api.wordnik.com/v4") : ApiClient(basePath) {

    /**
    * Fetches audio metadata for a word.
    * The metadata includes a time-expiring fileUrl which allows reading the audio file directly from the API.  Currently only audio pronunciations from the American Heritage Dictionary in mp3 format are supported.
    * @param word Word to get audio for. 
    * @param useCanonical Use the canonical form of the word (optional, default to false)
    * @param limit Maximum number of results to return (optional, default to 50)
    * @return kotlin.Array<AudioFile>
    */
    @Suppress("UNCHECKED_CAST")
    fun getAudio(word: kotlin.String, useCanonical: kotlin.String, limit: kotlin.Int) : kotlin.Array<AudioFile> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("useCanonical" to listOf("$useCanonical"), "limit" to listOf("$limit"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/word.json/{word}/audio".replace("{"+"word"+"}", "$word"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<AudioFile>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<AudioFile>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Return definitions for a word
    * 
    * @param word Word to return definitions for 
    * @param limit Maximum number of results to return (optional, default to 200)
    * @param partOfSpeech CSV list of part-of-speech types (optional)
    * @param includeRelated Return related words with definitions (optional, default to false)
    * @param sourceDictionaries Source dictionary to return definitions from.  If &#39;all&#39; is received, results are returned from all sources. If multiple values are received (e.g. &#39;century,wiktionary&#39;), results are returned from the first specified dictionary that has definitions. If left blank, results are returned from the first dictionary that has definitions. By default, dictionaries are searched in this order: ahd, wiktionary, webster, century, wordnet (optional)
    * @param useCanonical If true will try to return the correct word root (&#39;cats&#39; -&gt; &#39;cat&#39;). If false returns exactly what was requested. (optional, default to false)
    * @param includeTags Return a closed set of XML tags in response (optional, default to false)
    * @return kotlin.Array<Definition>
    */
    @Suppress("UNCHECKED_CAST")
    fun getDefinitions(word: kotlin.String, limit: kotlin.Int, partOfSpeech: kotlin.String, includeRelated: kotlin.String, sourceDictionaries: kotlin.Array<kotlin.String>, useCanonical: kotlin.String, includeTags: kotlin.String) : kotlin.Array<Definition> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("limit" to listOf("$limit"), "partOfSpeech" to listOf("$partOfSpeech"), "includeRelated" to listOf("$includeRelated"), "sourceDictionaries" to toMultiValue(sourceDictionaries.toList(), "csv"), "useCanonical" to listOf("$useCanonical"), "includeTags" to listOf("$includeTags"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/word.json/{word}/definitions".replace("{"+"word"+"}", "$word"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Definition>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Definition>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Fetches etymology data
    * 
    * @param word Word to return 
    * @param useCanonical If true will try to return the correct word root (&#39;cats&#39; -&gt; &#39;cat&#39;). If false returns exactly what was requested. (optional)
    * @return kotlin.Array<kotlin.String>
    */
    @Suppress("UNCHECKED_CAST")
    fun getEtymologies(word: kotlin.String, useCanonical: kotlin.String) : kotlin.Array<kotlin.String> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("useCanonical" to listOf("$useCanonical"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/word.json/{word}/etymologies".replace("{"+"word"+"}", "$word"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<kotlin.String>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<kotlin.String>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Returns examples for a word
    * 
    * @param word Word to return examples for 
    * @param includeDuplicates Show duplicate examples from different sources (optional, default to false)
    * @param useCanonical If true will try to return the correct word root (&#39;cats&#39; -&gt; &#39;cat&#39;). If false returns exactly what was requested. (optional, default to false)
    * @param skip Results to skip (optional, default to 0)
    * @param limit Maximum number of results to return (optional, default to 5)
    * @return ExampleSearchResults
    */
    @Suppress("UNCHECKED_CAST")
    fun getExamples(word: kotlin.String, includeDuplicates: kotlin.String, useCanonical: kotlin.String, skip: kotlin.Int, limit: kotlin.Int) : ExampleSearchResults {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("includeDuplicates" to listOf("$includeDuplicates"), "useCanonical" to listOf("$useCanonical"), "skip" to listOf("$skip"), "limit" to listOf("$limit"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/word.json/{word}/examples".replace("{"+"word"+"}", "$word"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<ExampleSearchResults>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as ExampleSearchResults
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Returns syllable information for a word
    * 
    * @param word Word to get syllables for 
    * @param useCanonical If true will try to return a correct word root (&#39;cats&#39; -&gt; &#39;cat&#39;). If false returns exactly what was requested. (optional, default to false)
    * @param sourceDictionary Get from a single dictionary. Valid options: ahd, century, wiktionary, webster, and wordnet. (optional)
    * @param limit Maximum number of results to return (optional, default to 50)
    * @return kotlin.Array<Syllable>
    */
    @Suppress("UNCHECKED_CAST")
    fun getHyphenation(word: kotlin.String, useCanonical: kotlin.String, sourceDictionary: kotlin.String, limit: kotlin.Int) : kotlin.Array<Syllable> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("useCanonical" to listOf("$useCanonical"), "sourceDictionary" to listOf("$sourceDictionary"), "limit" to listOf("$limit"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/word.json/{word}/hyphenation".replace("{"+"word"+"}", "$word"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Syllable>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Syllable>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Fetches bi-gram phrases for a word
    * 
    * @param word Word to fetch phrases for 
    * @param limit Maximum number of results to return (optional, default to 5)
    * @param wlmi Minimum WLMI for the phrase (optional, default to 0)
    * @param useCanonical If true will try to return the correct word root (&#39;cats&#39; -&gt; &#39;cat&#39;). If false returns exactly what was requested. (optional, default to false)
    * @return kotlin.Array<Bigram>
    */
    @Suppress("UNCHECKED_CAST")
    fun getPhrases(word: kotlin.String, limit: kotlin.Int, wlmi: kotlin.Int, useCanonical: kotlin.String) : kotlin.Array<Bigram> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("limit" to listOf("$limit"), "wlmi" to listOf("$wlmi"), "useCanonical" to listOf("$useCanonical"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/word.json/{word}/phrases".replace("{"+"word"+"}", "$word"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Bigram>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Bigram>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Given a word as a string, returns relationships from the Word Graph
    * 
    * @param word Word to fetch relationships for 
    * @param useCanonical If true will try to return the correct word root (&#39;cats&#39; -&gt; &#39;cat&#39;). If false returns exactly what was requested. (optional, default to false)
    * @param relationshipTypes Limits the total results per type of relationship type (optional)
    * @param limitPerRelationshipType Restrict to the supplied relatinship types (optional, default to 10)
    * @return kotlin.Array<Related>
    */
    @Suppress("UNCHECKED_CAST")
    fun getRelatedWords(word: kotlin.String, useCanonical: kotlin.String, relationshipTypes: kotlin.String, limitPerRelationshipType: kotlin.Int) : kotlin.Array<Related> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("useCanonical" to listOf("$useCanonical"), "relationshipTypes" to listOf("$relationshipTypes"), "limitPerRelationshipType" to listOf("$limitPerRelationshipType"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/word.json/{word}/relatedWords".replace("{"+"word"+"}", "$word"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<Related>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<Related>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Returns the Scrabble score for a word
    * 
    * @param word Word to get scrabble score for. 
    * @return kotlin.Long
    */
    @Suppress("UNCHECKED_CAST")
    fun getScrabbleScore(word: kotlin.String) : kotlin.Long {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf()
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/word.json/{word}/scrabbleScore".replace("{"+"word"+"}", "$word"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Long>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Long
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Returns text pronunciations for a given word
    * 
    * @param word Word to get pronunciations for 
    * @param useCanonical If true will try to return a correct word root (&#39;cats&#39; -&gt; &#39;cat&#39;). If false returns exactly what was requested. (optional, default to false)
    * @param sourceDictionary Get from a single dictionary (optional)
    * @param typeFormat Text pronunciation type (optional)
    * @param limit Maximum number of results to return (optional, default to 50)
    * @return kotlin.Array<TextPron>
    */
    @Suppress("UNCHECKED_CAST")
    fun getTextPronunciations(word: kotlin.String, useCanonical: kotlin.String, sourceDictionary: kotlin.String, typeFormat: kotlin.String, limit: kotlin.Int) : kotlin.Array<TextPron> {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("useCanonical" to listOf("$useCanonical"), "sourceDictionary" to listOf("$sourceDictionary"), "typeFormat" to listOf("$typeFormat"), "limit" to listOf("$limit"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/word.json/{word}/pronunciations".replace("{"+"word"+"}", "$word"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<kotlin.Array<TextPron>>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as kotlin.Array<TextPron>
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Returns a top example for a word
    * 
    * @param word Word to fetch examples for 
    * @param useCanonical If true will try to return the correct word root (&#39;cats&#39; -&gt; &#39;cat&#39;). If false returns exactly what was requested. (optional, default to false)
    * @return Example
    */
    @Suppress("UNCHECKED_CAST")
    fun getTopExample(word: kotlin.String, useCanonical: kotlin.String) : Example {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("useCanonical" to listOf("$useCanonical"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/word.json/{word}/topExample".replace("{"+"word"+"}", "$word"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<Example>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Example
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Given a word as a string, returns the WordObject that represents it
    * 
    * @param word String value of WordObject to return 
    * @param useCanonical If true will try to return the correct word root (&#39;cats&#39; -&gt; &#39;cat&#39;). If false returns exactly what was requested. (optional, default to false)
    * @param includeSuggestions Return suggestions (for correct spelling, case variants, etc.) (optional, default to true)
    * @return WordObject
    */
    @Suppress("UNCHECKED_CAST")
    fun getWord(word: kotlin.String, useCanonical: kotlin.String, includeSuggestions: kotlin.String) : WordObject {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("useCanonical" to listOf("$useCanonical"), "includeSuggestions" to listOf("$includeSuggestions"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/word.json/{word}".replace("{"+"word"+"}", "$word"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<WordObject>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as WordObject
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

    /**
    * Returns word usage over time
    * 
    * @param word Word to return 
    * @param useCanonical If true will try to return the correct word root (&#39;cats&#39; -&gt; &#39;cat&#39;). If false returns exactly what was requested. (optional, default to false)
    * @param startYear Starting Year (optional, default to 1800)
    * @param endYear Ending Year (optional, default to 2012)
    * @return FrequencySummary
    */
    @Suppress("UNCHECKED_CAST")
    fun getWordFrequency(word: kotlin.String, useCanonical: kotlin.String, startYear: kotlin.Int, endYear: kotlin.Int) : FrequencySummary {
        val localVariableBody: kotlin.Any? = null
        val localVariableQuery: MultiValueMap = mapOf("useCanonical" to listOf("$useCanonical"), "startYear" to listOf("$startYear"), "endYear" to listOf("$endYear"))
        val localVariableHeaders: kotlin.collections.Map<kotlin.String,kotlin.String> = mapOf()
        val localVariableConfig = RequestConfig(
            RequestMethod.GET,
            "/word.json/{word}/frequency".replace("{"+"word"+"}", "$word"),
            query = localVariableQuery,
            headers = localVariableHeaders
        )
        val response = request<FrequencySummary>(
            localVariableConfig,
            localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FrequencySummary
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
            else -> throw kotlin.IllegalStateException("Undefined ResponseType.")
        }
    }

}
